/*$file${.::control.c} #####################################################*/
/*
* Model: model.qm
* File:  ${.::control.c}
*
* This code has been generated by QM tool (https://state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${.::control.c} ##################################################*/
#include "qpc.h"
#include "balan.h"
#include "bsp.h"

//--------------------------------------------
static void buscar_par(uint16_t *v_celdas, uint8_t *par);
static void set_transfer(uint8_t celda_fuente, uint8_t celda_destino);

//---------------------------------------------
/*${AOs::Control} ..........................................................*/
typedef struct
{
/* protected: */
    QActive super;

/* private: */
    VceldasEvt vceldasEvt;
    Salida_estado salidas_update[CANT_SALIDAS];
    Salida_estado salidas_estado[CANT_SALIDAS];

} Control;

/* protected: */
static QState Control_initial(Control * const me, QEvt const * const e);
static QState Control_apagado(Control * const me, QEvt const * const e);
static QState Control_encendido(Control * const me, QEvt const * const e);

/* Local objects -----------------------------------------------------------*/
static Control l_control;

/* Global objects ----------------------------------------------------------*/
QActive * const AO_Control = &l_control.super;

//---------------------------------------------
/* Check for the minimum required QP version */
#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpc version 5.8.0 or higher required
#endif

/*${AOs::Control_ctor} .....................................................*/
void Control_ctor(void)
{
    uint8_t i;
    Control *me = &l_control;

    QActive_ctor(&me->super, Q_STATE_CAST(&Control_initial));

    for(i=0; i<CANT_SALIDAS; i++)
    {
        me->salidas_estado[i] = PWM_APAGADO;
        me->salidas_update[i] = PWM_APAGADO;
    }
}

/*${AOs::Control} ..........................................................*/
/*${AOs::Control::SM} ......................................................*/
static QState Control_initial(Control * const me, QEvt const * const e)
{
    /*${AOs::Control::SM::initial} */
    (void)e;

    QActive_subscribe(&me->super, APAGAR_SIG);
    QActive_subscribe(&me->super, ENCENDER_SIG);

    return Q_TRAN(&Control_apagado);
}
/*${AOs::Control::SM::apagado} .............................................*/
static QState Control_apagado(Control * const me, QEvt const * const e)
{
    QState status_;
    switch (e->sig) {
        /*${AOs::Control::SM::apagado} */
        case Q_ENTRY_SIG: {
            uint8_t i;

            for(i=0; i<CANT_SALIDAS; i++)
            {
                me->salidas_update[i] = PWM_APAGADO;
            }

            BSP_pwm_update(me->salidas_update);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Control::SM::apagado::ENC_PWM} */
        case ENC_PWM_SIG: {
            status_ = Q_TRAN(&Control_encendido);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Control::SM::encendido} ...........................................*/
static QState Control_encendido(Control * const me, QEvt const * const e)
{
    QState status_;
    switch (e->sig) {
    	case Q_ENTRY_SIG: {

    		status_ = Q_HANDLED();
    		break;
    	}
        /*${AOs::Control::SM::encendido::APA_PWM} */
        case APA_PWM_SIG: {
            status_ = Q_TRAN(&Control_apagado);
            break;
        }
        /*${AOs::Control::SM::encendido::MED_CON} */
        case MED_CON_SIG: {
            uint16_t v_celdas[CANT_CELDAS];
            uint8_t i;
            uint8_t par[2];

            for(i=0; i<CANT_CELDAS; i++)
            {
                v_celdas[i] = Q_EVT_CAST(VceldasEvt)->v_celdas[i];
            }

            buscar_par(v_celdas, par);
            set_transfer(par[0], par[1]);

        	BSP_pwm_update(me->salidas_update);

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//---------------------------------------------
static void buscar_par(uint16_t *v_celdas, uint8_t *par)
{
	int32_t deltamax=0;
	int32_t delta_1, delta_2;
	uint32_t i;
	uint32_t v_cel1, v_cel2;

	par[0] = 0;
	par[1] = 0;

	for(i=0; i<CANT_SALIDAS; i++)		//calcular las diferencias de tensión para los pares y quedarse con el máximo
	{
		v_cel1 = v_celdas[i];
		v_cel2 = v_celdas[i+1];

		//si al menos una está fuera del rango fuerte, ignorar el par
		//si la fuente está debajo del mínimo débil, ignorar el par
		//si el destino está encima del máximo débil, ignorar el par

		//verificar que ambas estén dentro del rango fuerte
		if(CELDA_V_MIN_FUERTE_mV < v_cel1 && v_cel1 < CELDA_V_MAX_FUERTE_mV && \
		   CELDA_V_MIN_FUERTE_mV < v_cel2 && v_cel2 < CELDA_V_MAX_FUERTE_mV)
		{
			delta_1 = v_cel1 - v_cel2;
			delta_2 = v_cel2 - v_cel1;

			if(delta_1 > deltamax)	//se queda con el máximo
			{
				//si la fuente está por encima del mínimo débil
				//y el destino está por debajo del máximo débil
				if(CELDA_V_MIN_DEBIL_mV < v_cel1 && v_cel2 < CELDA_V_MAX_DEBIL_mV)
				{
					deltamax = delta_1;
					par[0] = i;			//fuente
					par[1] = i+1;		//destino
				}
			}
			else if(delta_2 > deltamax)
			{
				if(CELDA_V_MIN_DEBIL_mV < v_cel2 && v_cel1 < CELDA_V_MAX_DEBIL_mV)
				{
					deltamax = delta_2;
					par[0] = i+1;		//fuente
					par[1] = i;			//destino
				}
			}
		}
	}

	if(deltamax < (int32_t)DELTA_V_MIN_mV)	//si la diferencia es muy chica, ignorar
	{
		par[0] = 0;
		par[1] = 0;
	}
}
//--------------------------------------------------------
static void set_transfer(uint8_t celda_fuente, uint8_t celda_destino)
{
	uint32_t i;
	Control *me=&l_control;

	for(i=0; i<CANT_SALIDAS; i++)
	{
		me->salidas_update[i] = PWM_APAGADO;
	}

	if(celda_fuente == 0)
	{
		if(celda_destino == 1)
		{
			me->salidas_update[0] = PWM_ARRIBA_PRIMERO;	//fuente: 0, destino: 1
		}
	}
	else if(celda_fuente == 1)
	{
		if(celda_destino == 0)
		{
			me->salidas_update[0] = PWM_ABAJO_PRIMERO; //fuente: 1, destino: 0
		}
		else if(celda_destino == 2)
		{
			me->salidas_update[1] = PWM_ARRIBA_PRIMERO;	//fuente: 1, destino: 2
		}
	}
	else if(celda_fuente == 2)
	{
		if(celda_destino == 1)
		{
			me->salidas_update[1] = PWM_ABAJO_PRIMERO;	//fuente: 2, destino: 1
		}
		else if(celda_destino == 3)
		{
			me->salidas_update[2] = PWM_ARRIBA_PRIMERO;	//fuente: 2, destino: 3
		}
	}
	else if(celda_fuente == 3)
	{
		if(celda_destino == 2)
		{
			me->salidas_update[2] = PWM_ABAJO_PRIMERO;	//fuente: 3, destino: 2
		}
	}
}
