/*$file${.::medicion.c} ####################################################*/
/*
* Model: model.qm
* File:  ${.::medicion.c}
*
* This code has been generated by QM tool (https://state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${.::medicion.c} #################################################*/
#include "qpc.h"
#include "balan.h"
#include "bsp.h"

//----------------------------------------
/*${AOs::Medicion} .........................................................*/
typedef struct
{
/* protected: */
    QActive super;

/* private: */
    uint32_t celdas_acum[CANT_CELDAS];
    uint32_t celdas_conta[CANT_CELDAS];
    uint16_t celdas_prom[CANT_CELDAS];
    int8_t celda_activa;
    QTimeEvt timeEvt;
    MedicionEvt medicionEvt;

} Medicion;

/* private: */
static void Medicion_adc_limpiar(Medicion * const me);

/* protected: */
static QState Medicion_initial(Medicion * const me, QEvt const * const e);
static QState Medicion_apagado(Medicion * const me, QEvt const * const e);
static QState Medicion_encendido(Medicion * const me, QEvt const * const e);

/* Local objects -----------------------------------------------------------*/
static Medicion l_medicion;

/* Global objects ----------------------------------------------------------*/
QActive * const AO_Medicion = &l_medicion.super;

//---------------------------------------
/* Check for the minimum required QP version */
#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpc version 5.8.0 or higher required
#endif

/*${AOs::Medicion_ctor} ....................................................*/
void Medicion_ctor(void)
{
    uint8_t i;
    Medicion *me = &l_medicion;

    QActive_ctor(&me->super, Q_STATE_CAST(&Medicion_initial));
    QTimeEvt_ctorX(&me->timeEvt, &me->super, CICLO_CON_SIG, 0U);

    for(i=0; i<CANT_CELDAS; i++)
    {
        me->celdas_acum[i] = 0;
        me->celdas_conta[i] = 0;
        me->celdas_prom[i] = 0;
    }

    me->celda_activa = 0;
}

/*${AOs::Medicion} .........................................................*/
/*${AOs::Medicion::adc_limpiar} ............................................*/
static void Medicion_adc_limpiar(Medicion * const me)
{
    uint8_t i;

    for(i=0; i<CANT_CELDAS; i++)
    {
        me->celdas_acum[i] = 0;
        me->celdas_conta[i] = 0;
        me->celdas_prom[i] = 0;
    }

    me->celda_activa = 0;
}

/*${AOs::Medicion::SM} .....................................................*/
static QState Medicion_initial(Medicion * const me, QEvt const * const e)
{
    /*${AOs::Medicion::SM::initial} */
    (void)e;

    QActive_subscribe(&me->super, APAGAR_SIG);
    QActive_subscribe(&me->super, ENCENDER_SIG);

    return Q_TRAN(&Medicion_apagado);
}

/*${AOs::Medicion::SM::apagado} ............................................*/
static QState Medicion_apagado(Medicion * const me, QEvt const * const e)
{
    QState status_;

    switch (e->sig)
    {
        /*${AOs::Medicion::SM::apagado} */
        case Q_ENTRY_SIG: {
            QEvt *pe = Q_NEW(QEvt, APA_PWM_SIG);
            QACTIVE_POST(AO_Control, pe, me);

            BSP_adc_stop();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Medicion::SM::apagado::ENCENDER} */
        case ENCENDER_SIG: {
            status_ = Q_TRAN(&Medicion_encendido);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Medicion::SM::encendido} ..........................................*/
static QState Medicion_encendido(Medicion * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Medicion::SM::encendido} */
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->timeEvt, CONTROL_TIEMPO, CONTROL_TIEMPO);

            QEvt *pe = Q_NEW(QEvt, ENC_PWM_SIG);
            QACTIVE_POST(AO_Control, pe, me);

            Medicion_adc_limpiar(me);

            BSP_adc_start();

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Medicion::SM::encendido} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->timeEvt);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Medicion::SM::encendido::APAGAR} */
        case APAGAR_SIG: {
            status_ = Q_TRAN(&Medicion_apagado);
            break;
        }
        /*${AOs::Medicion::SM::encendido::MED_ADC} */
        case MED_ADC_SIG: {
            uint8_t celda;
            uint16_t valor;
            uint32_t *acum;
            uint32_t *conta;

            celda = Q_EVT_CAST(MedicionEvt)->celda;
            valor = Q_EVT_CAST(MedicionEvt)->valor;

            if(me->celda_activa == celda)
            {
                acum = &(me->celdas_acum[celda]);
                conta = &(me->celdas_conta[celda]);

                *acum += valor;
                (*conta)++;

                if(*conta >= ADC_CANT_PROMEDIO)
                {
                    me->celdas_prom[celda] = *acum / *conta;

                    *acum = 0;
                    *conta = 0;

                    celda++;
                    if(celda >= CANT_CELDAS)
                    {
                        celda = 0;
                    }

                    me->celda_activa = celda;

                    BSP_adc_sel_celda(celda);
                }

                BSP_adc_convert();
            }
            else
            {
                BSP_adc_sel_celda(me->celda_activa);
                BSP_adc_convert();
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Medicion::SM::encendido::CICLO_CON} */
        case CICLO_CON_SIG: {
            uint8_t i;
            VceldasEvt *pe = Q_NEW(VceldasEvt, MED_CON_SIG);

            for(i=0; i<CANT_CELDAS; i++)
            {
                pe->v_celdas[i] = me->celdas_prom[i];
            }

            QACTIVE_POST(AO_Control, &pe->super, me);

            BSP_led_toggle();

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
