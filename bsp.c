

#include "qpc.h"
#include "balan.h"
#include "bsp.h"

#include "qwin_gui.h" /* QWIN GUI */
#include "resource.h" /* GUI resource IDs generated by the resource editior */

#include "sim_bat.h"

#include <stdint.h>
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>

Q_DEFINE_THIS_FILE

#define GUI_CANT_BOTON      (2)
#define GUI_CANT_LED        (8)
#define GUI_CANT_7SEG_DIG   (2)
#define GUI_CANT_7SEG_CHAR  (10)

#define GUI_CANT_CELDAS     (4)
#define GUI_CANT_SALIDAS	(3)

#if (GUI_CANT_CELDAS < CANT_CELDAS)
#error Muchas celdas para esta GUI
#endif

/* GUI local variables ---------------------------------------------------------*/
static HINSTANCE l_hInst;   /* this application instance */
static HWND      l_hWnd;    /* main window handle */
static LPSTR     l_cmdLine; /* the command line string */

static SegmentDisplay l_userLED[GUI_CANT_LED];
static const UINT l_LEDID[GUI_CANT_LED] = {IDC_LED0, IDC_LED1, IDC_LED2, IDC_LED3,\
										   IDC_LED4, IDC_LED5, IDC_LED6, IDC_LED7};

static SegmentDisplay l_7seg;
static const UINT l_7segID[GUI_CANT_7SEG_DIG] = {IDC_SEG0, IDC_SEG1};
static const UINT l_7segBMP[GUI_CANT_7SEG_CHAR] = {IDB_SEG0, IDB_SEG1, IDB_SEG2,
                                            IDB_SEG3, IDB_SEG4, IDB_SEG5,
                                            IDB_SEG6, IDB_SEG7, IDB_SEG8,
                                            IDB_SEG9};

static OwnerDrawnButton l_userBtn[GUI_CANT_BOTON];
static const UINT l_BtnID[GUI_CANT_BOTON] = {IDC_USER0, IDC_USER1};

//----------------------------------------------------------------------------

/* Local functions ---------------------------------------------------------*/
static LRESULT CALLBACK WndProc(HWND hWnd, UINT iMsg,
                                WPARAM wParam, LPARAM lParam);

static void gui_boton_init(void);
static void gui_boton_presionado(OwnerDrawnButton *boton);
static void gui_boton_liberado(OwnerDrawnButton *boton);
static UINT gui_boton_buscar(UINT ctlID);
static void gui_led_init(void);
static void gui_7seg_init(void);
static void limpiar_botones(void);
static void limpiar_leds(void);
static void limpiar_7seg(void);

void BSP_updateScore(uint16_t score);

/*..........................................................................*/

/* Local-scope objects -----------------------------------------------------*/
// mapeo de celda a canal de ADC
static const uint8_t canal_celda[CANT_CELDAS]=\
		{ADC_CANAL_CEL1, ADC_CANAL_CEL2};

//------------------------------------------------------------------
static Pwm_salida salidas[CANT_SALIDAS];
static uint16_t v_celdas[GUI_CANT_CELDAS];
static uint8_t l_celda_midiendo = 0;
static uint8_t l_pausar_sim = 0;

//--------------------------------------------------------------------------
/* BSP functions ===========================================================*/
void BSP_init(void)
{
	sim_bat_init(GUI_CANT_CELDAS);
}
/*..........................................................................*/
void BSP_terminate(int16_t result)
{
    (void)result;

    QF_stop(); /* stop the main QF application and the ticker thread */

    /* cleanup all QWIN resources... */
    limpiar_botones();
    limpiar_leds();
    limpiar_7seg();

    /* end the main dialog */
    EndDialog(l_hWnd, result);
}
/*..........................................................................*/
bool BSP_isThrottle(void) /* is the throttle button depressed? */
{
    return OwnerDrawnButton_isDepressed(&l_userBtn[1]) != 0;
}
//---------------------------------------------------------------------------
void BSP_config_adc(void)
{
}
//---------------------------------------------------------------------------
void BSP_config_pwm(void)
{
}
//---------------------------------------------------------------------------
void BSP_pwm_update(Salida_estado *salidas_est)
{
	uint8_t i;
	int16_t corriente_celda[CANT_CELDAS] = {0};
	static SegmentDisplay *leds[2*GUI_CANT_SALIDAS] = {&l_userLED[2], &l_userLED[3],\
												   &l_userLED[4], &l_userLED[5],\
												   &l_userLED[6], &l_userLED[7]};

	for(i=0; i<CANT_SALIDAS; i++)
	{
		salidas[i].update = salidas_est[i];

		if(salidas[i].update == PWM_APAGADO)
		{
			SegmentDisplay_setSegment(leds[i*2], 0U, 0U);
			SegmentDisplay_setSegment(leds[i*2+1], 0U, 0U);
		}
		else if(salidas[i].update == PWM_ARRIBA_PRIMERO)
		{
			SegmentDisplay_setSegment(leds[i*2], 0U, 0U);
			SegmentDisplay_setSegment(leds[i*2+1], 0U, 1U);

			corriente_celda[i] += -SIM_BAT_CORRIENTE_mA;
			corriente_celda[i+1] += SIM_BAT_CORRIENTE_mA;
		}
		else if(salidas[i].update == PWM_ABAJO_PRIMERO)
		{
			SegmentDisplay_setSegment(leds[i*2], 0U, 1U);
			SegmentDisplay_setSegment(leds[i*2+1], 0U, 0U);

			corriente_celda[i] += SIM_BAT_CORRIENTE_mA;
			corriente_celda[i+1] += -SIM_BAT_CORRIENTE_mA;
		}
	}

	for(i=0; i<CANT_CELDAS; i++)
	{
		sim_bat_set_corriente(i, corriente_celda[i]);
	}
}
//---------------------------------------------------------------------------
void BSP_adc_stop(void)
{

}
//---------------------------------------------------------------------------
void BSP_adc_start(void)
{
}
//---------------------------------------------------------------------------
void BSP_adc_convert(void)
{
}
//---------------------------------------------------------------------------
void BSP_adc_sel_celda(uint8_t celda)
{
    l_celda_midiendo = celda;
	//BSP_led_on(0, 1);
	BSP_updateScore((uint16_t)celda);
}
//---------------------------------------------------------------------------
uint8_t BSP_adc_canal(uint8_t celda)
{
	uint8_t retorno=ADC_CANAL_NOCEL;

	if(celda < CANT_CELDAS)
	{
		retorno = canal_celda[celda];
	}

	return retorno;
}
//--------------------------------------------------------------------------
uint8_t BSP_adc_celda(uint8_t canal)
{
	uint8_t retorno=ADC_CANAL_NOCEL;
	uint8_t i;

	for(i=0; i<CANT_CELDAS; i++)
	{
		if(canal_celda[i] == canal)
		{
			retorno = i;
			break;
		}
	}
	return retorno;
}
//---------------------------------------------------------------------------
void BSP_adc_int_off(uint8_t celda)
{
    (void)celda;
}
//---------------------------------------------------------------------------
void BSP_adc_int_on(uint8_t celda)
{
	(void)celda;
}
//---------------------------------------------------------------------------
void BSP_pwm_apagar(void)
{
}
//---------------------------------------------------------------------------
void BSP_pwm_activar(Pwm_salida *pwm_salidas)
{
    (void)pwm_salidas;
}
//---------------------------------------------------------------------------
void BSP_pwm_int_off(void)
{
}
//---------------------------------------------------------------------------
void BSP_pwm_int_on(void)
{
}
//---------------------------------------------------------------------------
void BSP_led_toggle(void)
{
	static uint8_t estado=0;

	if(estado == 0)
	{
		estado = 1;
		SegmentDisplay_setSegment(&l_userLED[0], 0U, 1U);
	}
	else
	{
		estado = 0;
		SegmentDisplay_setSegment(&l_userLED[0], 0U, 0U);
	}
}
//---------------------------------------------------------------------------
void BSP_led_on(uint32_t puerto, uint32_t led)
{
	static uint8_t estado[GUI_CANT_LED]={0};
    (void)puerto;
    (void)led;

	if(estado[led] == 0)
	{
		estado[led] = 1;
		SegmentDisplay_setSegment(&l_userLED[led], 0U, 1U);
	}
	else
	{
		estado[led] = 0;
		SegmentDisplay_setSegment(&l_userLED[led], 0U, 0U);
	}
}
//---------------------------------------------------------------------------
void BSP_led_off(uint32_t puerto, uint32_t led)
{
    (void)puerto;
    (void)led;
}
//---------------------------------------------------------------------------
/*..........................................................................*/
void BSP_updateScore(uint16_t score)
{
    uint8_t seg[5];

    if (score == 0U)
    {
        //BSP_paintString(1U, BSP_SCREEN_HEIGHT - 8U, "SCORE:");
    }

    seg[0] = score % 10U; score /= 10U;
    seg[1] = score % 10U; score /= 10U;
    seg[2] = score % 10U; score /= 10U;
    seg[3] = score % 10U;

    /* update the score in the l_scoreBoard SegmentDisplay */
    SegmentDisplay_setSegment(&l_7seg, 0U, (UINT)seg[0]);
    SegmentDisplay_setSegment(&l_7seg, 1U, (UINT)seg[1]);
}
/*..........................................................................*/
//----------------------------------------------------------------------------
/* QF callbacks ============================================================*/
void QF_onStartup(void)
{
    QF_setTickRate(BSP_TICKS_PER_SEC); /* set the desired tick rate */
}
/*..........................................................................*/
void QF_onCleanup(void)
{
}
/*..........................................................................*/
void QF_onClockTick(void)
{
    static uint32_t cant_ticks = 0;
    static QEvt encenderEvt = {ENCENDER_SIG, 0, 0};
	static MedicionEvt medicionEvt = {{MED_ADC_SIG, 0, 0}, 0, 0};
	static uint32_t tiempo_tick_ms = 1000U / BSP_TICKS_PER_SEC;

    QF_TICK_X(0U, &l_clock_tick);  /* process time events for rate 0 */

	cant_ticks++;
	
    if(cant_ticks == 200)	//envía evento de comienzo
    {
    	QF_PUBLISH(&encenderEvt, &Systick_Handler);

		sim_bat_set_tension(0, 3333);
		sim_bat_set_tension(1, 3555);
		sim_bat_set_tension(2, 3299);
		sim_bat_set_tension(3, 3900);
    }

	if(cant_ticks > 200)
	{
		medicionEvt.celda = l_celda_midiendo;
		medicionEvt.valor = sim_bat_get_tension(l_celda_midiendo);
		QACTIVE_POST(AO_Medicion, &medicionEvt.super, me);

		if(l_pausar_sim == 0)
		{
			if(((cant_ticks*tiempo_tick_ms) % SIM_BAT_UPDATE_mS) == 0)
			{
				sim_bat_update(SIM_BAT_UPDATE_mS);
				SetDlgItemInt(l_hWnd, IDC_VCEL0, sim_bat_get_tension(0), FALSE);
				SetDlgItemInt(l_hWnd, IDC_VCEL1, sim_bat_get_tension(1), FALSE);
				SetDlgItemInt(l_hWnd, IDC_VCEL2, sim_bat_get_tension(2), FALSE);
				SetDlgItemInt(l_hWnd, IDC_VCEL3, sim_bat_get_tension(3), FALSE);
			}
		}
	}

//    if(cant_ticks == 600)
//    {
//    	encenderEvt.sig = APAGAR_SIG;
//    	QF_PUBLISH(&encenderEvt, &Systick_Handler);
//    }
//    if(cant_ticks == 900)
//    {
//    	encenderEvt.sig = ENCENDER_SIG;
//    	QF_PUBLISH(&encenderEvt, &Systick_Handler);
//    }
//    if(cant_ticks == 1300)
//    {
//    	encenderEvt.sig = APA_PWM_SIG;
//    	QACTIVE_POST(AO_Control, &encenderEvt, &Systick_Handler);
//    }
//    if(cant_ticks == 1700)
//    {
//    	encenderEvt.sig = ENC_PWM_SIG;
//    	QACTIVE_POST(AO_Control, &encenderEvt, &Systick_Handler);
//    }

}
/*..........................................................................*/
void QV_onIdle(void)
{
    /* toggle the User LED on and then off, see NOTE01 */
    QF_INT_DISABLE();

    QF_INT_ENABLE();
}
/*..........................................................................*/
void Q_onAssert(char const *module, int loc)
{
    /*
    * NOTE: add here your application-specific error handling
    */
    (void)module;
    (void)loc;
    QS_ASSERTION(module, loc, (uint32_t)10000U); /* report assertion to QS */

	char texto[30];
	char numero[6];

	strcpy(texto, module);
	sprintf(numero, " %d", loc);
	strcat(texto, numero);

	MessageBox(l_hWnd, texto, "Assertion", MB_OK);
	BSP_terminate(0);
}
/*..........................................................................*/
/* thread function for running the application main_gui() */
static DWORD WINAPI appThread(LPVOID par)
{
    (void)par; /* unused parameter */
    return (DWORD)main_gui(); /* run the QF application */
}

/*--------------------------------------------------------------------------*/
int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst,
    LPSTR cmdLine, int iCmdShow)
{
    HWND hWnd;
    MSG  msg;

    (void)hPrevInst; /* unused parameter */

    l_hInst   = hInst;   /* save the application instance */
    l_cmdLine = cmdLine; /* save the command line string */

    //AllocConsole();

    /* create the main custom dialog window */
    hWnd = CreateCustDialog(hInst, IDD_APPLICATION, NULL,
        &WndProc, "QP_APP");
    ShowWindow(hWnd, iCmdShow);  /* show the main window */

    /* enter the message loop... */
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    //FreeConsole();
    BSP_terminate(0);

    return msg.wParam;
}

/*..........................................................................*/
static LRESULT CALLBACK WndProc(HWND hWnd, UINT iMsg,
    WPARAM wParam, LPARAM lParam)
{
    switch (iMsg) {

        /* Perform initialization upon creation of the main dialog window
        * NOTE: Any child-windows are NOT created yet at this time, so
        * the GetDlgItem() function can't be used (it will return NULL).
        */
        case WM_CREATE: {
            l_hWnd = hWnd; /* save the window handle */

            /* initialize the owner-drawn buttons...
            * NOTE: must be done *before* the first drawing of the buttons,
            * so WM_INITDIALOG is too late.
            */
            gui_boton_init();

            return 0;
        }

        /* Perform initialization after all child windows have been created */
        case WM_INITDIALOG: {
            gui_led_init();
            gui_7seg_init();

            SendDlgItemMessage(hWnd, IDC_VCEL0, EM_LIMITTEXT, 4, 0L);
            SetDlgItemText(hWnd, IDC_VCEL0, "0000");

            SendDlgItemMessage(hWnd, IDC_VCEL1, EM_LIMITTEXT, 4, 0L);
            SetDlgItemText(hWnd, IDC_VCEL1, "0000");

            SendDlgItemMessage(hWnd, IDC_VCEL2, EM_LIMITTEXT, 4, 0L);
            SetDlgItemText(hWnd, IDC_VCEL2, "0000");

            SendDlgItemMessage(hWnd, IDC_VCEL3, EM_LIMITTEXT, 4, 0L);
            SetDlgItemText(hWnd, IDC_VCEL3, "0000");

            /* --> QP: spawn the application thread to run main_gui() */
            Q_ALLEGE(CreateThread(NULL, 0, &appThread, NULL, 0, NULL)
                != (HANDLE)0);
            return 0;
        }

        case WM_DESTROY: {
            OutputDebugString("DESTROY\n");
            PostQuitMessage(0);
            return 0;
        }

        /* commands from regular buttons and menus... */
        case WM_COMMAND: {
//            SetFocus(hWnd);
            switch (wParam) {
                case IDOK:
                case IDCANCEL: {
                    OutputDebugString("QUIT\n");
                    PostQuitMessage(0);
                    break;
                }
                case IDC_OK_0:
                {
                    v_celdas[0] = (uint16_t)GetDlgItemInt(hWnd, IDC_VCEL0, NULL, FALSE);
					sim_bat_set_tension(0, v_celdas[0]);
                    BSP_updateScore(v_celdas[0]);
                    break;
                }
                case IDC_OK_1:
                {
                    v_celdas[1] = (uint16_t)GetDlgItemInt(hWnd, IDC_VCEL1, NULL, FALSE);
					sim_bat_set_tension(1, v_celdas[1]);
					BSP_updateScore(v_celdas[1]);
                    break;
                }
                case IDC_OK_2:
                {
                    v_celdas[2] = (uint16_t)GetDlgItemInt(hWnd, IDC_VCEL2, NULL, FALSE);
					sim_bat_set_tension(2, v_celdas[2]);
                    break;
                }
                case IDC_OK_3:
                {
                    v_celdas[3] = (uint16_t)GetDlgItemInt(hWnd, IDC_VCEL3, NULL, FALSE);
					sim_bat_set_tension(3, v_celdas[3]);
                    break;
                }
            }
            return 0;
        }

        /* owner-drawn buttons... */
        case WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT pdis = (LPDRAWITEMSTRUCT)lParam;
            int8_t boton_ind = gui_boton_buscar(pdis->CtlID);

            if(boton_ind != -1)
            {
                switch (OwnerDrawnButton_draw(&l_userBtn[boton_ind], pdis))
                {
                    case BTN_DEPRESSED: {
                        gui_boton_presionado(&l_userBtn[boton_ind]);
                        break;
                    }
                    case BTN_RELEASED: {
                        gui_boton_liberado(&l_userBtn[boton_ind]);
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }
            return 0;
        }

        /* mouse wheel input... */
        case WM_MOUSEWHEEL:
        {
            OutputDebugString("MOUSEWHEEL\n");
            return 0;
        }

        /* keyboard input... */
        case WM_KEYDOWN:
        {
            OutputDebugString("KEYDOWN\n");
            switch (wParam)
            {
                case VK_SPACE:
//                    OwnerDrawnButton_set(&l_userBtn[0], 1);
                    break;
            }
            return 0;
        }
    }
    return DefWindowProc(hWnd, iMsg, wParam, lParam);
}
/*--------------------------------------------------------------------------*/
static void gui_boton_init(void)
{
    uint8_t i;

    for(i=0; i<GUI_CANT_BOTON; i++)
    {
        OwnerDrawnButton_init(&l_userBtn[i], l_BtnID[i],
            LoadBitmap(l_hInst, MAKEINTRESOURCE(IDB_BTN_UP)),
            LoadBitmap(l_hInst, MAKEINTRESOURCE(IDB_BTN_DWN)),
            LoadCursor(NULL, IDC_HAND));
    }
}
/*--------------------------------------------------------------------------*/
static void gui_boton_presionado(OwnerDrawnButton *boton)
{
    switch(boton->itemID)
    {
        case IDC_USER0:
        {
            SegmentDisplay_setSegment(&l_userLED[0], 0U, 1U);
            SegmentDisplay_setSegment(&l_7seg, 0, 2);
            SegmentDisplay_setSegment(&l_7seg, 1, 5);
            break;
        }
        case IDC_USER1:
        {
            SegmentDisplay_setSegment(&l_userLED[1], 0U, 1U);
			l_pausar_sim ^= 0xff;
            break;
        }
        default:
        {
            break;
        }
    }
}
//---------------------------------------------------
static void gui_boton_liberado(OwnerDrawnButton *boton)
{
    switch(boton->itemID)
    {
        case IDC_USER0:
        {
            SegmentDisplay_setSegment(&l_userLED[0], 0U, 0U);
            break;
        }
        case IDC_USER1:
        {
            SegmentDisplay_setSegment(&l_userLED[1], 0U, 0U);
            break;
        }
        default:
        {
            break;
        }
    }
}
//---------------------------------------------------------------------
static UINT gui_boton_buscar(UINT ctlID)
{
    uint8_t i;
    UINT retorno = -1;

    for(i=0; i<GUI_CANT_BOTON; i++)
    {
        if(l_BtnID[i] == ctlID)
        {
            retorno = i;
            break;
        }
    }

    return retorno;
}
//---------------------------------------------------------------------
static void gui_led_init(void)
{
    uint8_t i;

    for(i=0; i<GUI_CANT_LED; i++)
    {
        SegmentDisplay_init(&l_userLED[i],
            1U,  /* 1 "segment" (the LED0 itself) */
            2U); /* 2 bitmaps (for LED0 OFF/ON states) */
        SegmentDisplay_initSegment(&l_userLED[i], 0U, l_LEDID[i]);

        SegmentDisplay_initBitmap(&l_userLED[i],
            0U, LoadBitmap(l_hInst, MAKEINTRESOURCE(IDB_LED_OFF)));

        SegmentDisplay_initBitmap(&l_userLED[i],
            1U, LoadBitmap(l_hInst, MAKEINTRESOURCE(IDB_LED_ON)));
    }
}
//------------------------------------------------------
static void gui_7seg_init(void)
{
    uint8_t i;

    SegmentDisplay_init(&l_7seg,
        GUI_CANT_7SEG_DIG, /* digitos */
        GUI_CANT_7SEG_CHAR); /* 10 bitmaps (for 0-9 states) */

    for(i=0; i<GUI_CANT_7SEG_DIG; i++)
    {
        SegmentDisplay_initSegment(&l_7seg, i, l_7segID[i]);
    }

    for(i=0; i<GUI_CANT_7SEG_CHAR; i++)
    {
        SegmentDisplay_initBitmap(&l_7seg, i,
            LoadBitmap(l_hInst, MAKEINTRESOURCE(l_7segBMP[i])));
    }
}
//---------------------------------------------------------------------
static void limpiar_botones(void)
{
    uint8_t i;

    for(i=0; i<GUI_CANT_BOTON; i++)
    {
        OwnerDrawnButton_xtor(&l_userBtn[i]); /* cleanup the l_userBtn0 resources */
    }
}
//--------------------------------------------------------
static void limpiar_leds(void)
{
    uint8_t i;

    for(i=0; i<GUI_CANT_LED; i++)
    {
        SegmentDisplay_xtor(&l_userLED[i]);   /* cleanup the l_userLED0 resources */
    }
}
//------------------------------------------------------------------
static void limpiar_7seg(void)
{
    SegmentDisplay_xtor(&l_7seg); /* cleanup the scoreBoard resources */
}

/*****************************************************************************
* NOTE00:
* The QF_AWARE_ISR_CMSIS_PRI constant from the QF port specifies the highest
* ISR priority that is disabled by the QF framework. The value is suitable
* for the NVIC_SetPriority() CMSIS function.
*
* Only ISRs prioritized at or below the QF_AWARE_ISR_CMSIS_PRI level (i.e.,
* with the numerical values of priorities equal or higher than
* QF_AWARE_ISR_CMSIS_PRI) are allowed to call the QK_ISR_ENTRY/QK_ISR_ENTRY
* macros or any other QF/QK  services. These ISRs are "QF-aware".
*
* Conversely, any ISRs prioritized above the QF_AWARE_ISR_CMSIS_PRI priority
* level (i.e., with the numerical values of priorities less than
* QF_AWARE_ISR_CMSIS_PRI) are never disabled and are not aware of the kernel.
* Such "QF-unaware" ISRs cannot call any QF/QK services. In particular they
* can NOT call the macros QK_ISR_ENTRY/QK_ISR_ENTRY. The only mechanism
* by which a "QF-unaware" ISR can communicate with the QF framework is by
* triggering a "QF-aware" ISR, which can post/publish events.
*
* NOTE01:
* The User LED is used to visualize the idle loop activity. The brightness
* of the LED is proportional to the frequency of invocations of the idle loop.
* Please note that the LED is toggled with interrupts locked, so no interrupt
* execution time contributes to the brightness of the User LED.
*/
